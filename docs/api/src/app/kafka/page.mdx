# Kafka

We use the Apache Kafka as the main broker for all of our microservices. It is a distributed streaming platform that is used for building real-time data pipelines and streaming applications. It is horizontally scalable, fault-tolerant, and fast.

## Kafka Topics

We have a few topics that are used for communication between microservices. The topics are:
| Topic Name | Description |
|------------|-------------|
| `wallets` | This topic is used for communication between the `wallets` microservice and the `gateway` microservice. |
| `notifications` | This topic is used for communication between the `notifications` microservice and other microservices. |


We are limited to create topic on the fly because of the Kafka configuration. If you want to create a new topic, you need to add it to the `docker-compose.yml` file and restart the Kafka container.
For the sake of simplicity, we are using the `kcat` tool to produce and consume messages from the Kafka topics. You can install it by running the following command:

```bash
brew install kcat
```

### Producing and Consuming Messages

To produce a message to a topic, you can run the following command:

```bash
kcat -P -b localhost:9092 -t wallets
```

To consume a message from a topic, you can run the following command:

```bash
kcat -C -b localhost:9092 -t wallets
```

You can find more information about the `kcat` tool [here](https://github.com/edenhill/kcat).

## Consuming Kafka Messages

In Laravel, we use the console commands to consume messages from the Kafka topics. You have to run the command before you can consume messages from the Kafka topics.

```bash
php artisan kafka:consume-wallets-topic
```

After running the command, you can consume messages from the Kafka topics. Inside the handle method of the console command, you can use the `Kafka` facade to create a consumer and consume messages from the Kafka topics.
And then user defined actions `patterns` and `data` are handled by the `KafkaCommandHandler` class.

```php {{ title: "app/Console/Commands/NotificationTopicConsumer.php" }}
<?php

namespace App\Console\Commands;

use App\Kafka\KafkaCommandHandler;
use Carbon\Exceptions\Exception;
use Illuminate\Console\Command;
use Junges\Kafka\Contracts\KafkaConsumerMessage;
use Junges\Kafka\Exceptions\KafkaConsumerException;
use Junges\Kafka\Facades\Kafka;

class NotificationTopicConsumer extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'kafka:consume-notification-topic';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Consume messages from the notification topic';

    /**
     * Execute the console command.
     * @throws KafkaConsumerException
     * @throws Exception
     */
    public function handle(): void
    {
        $consumer = Kafka::createConsumer()
            ->subscribe('notifications')
            ->withHandler(function (KafkaConsumerMessage $message) {
                print_r($message->getBody());

                KafkaCommandHandler::handle($message);
            })
            ->withDlq('notifications-dlq')
            ->withConsumerGroupId('notification-consumer-group')
            ->build();

        $consumer->consume();
    }
}
```

## Handling Kafka Messages

Inside the `app/Kafka` directory, you can find the `ActionMapper` and `KafkaCommandHandler` classes. These classes are used to handle the communication between microservices using the Kafka topics.
We also employ the power of Command Pattern to handle the incoming messages from the Kafka topics.


  ```php {{title: "app/Kafka/KafkaCommandHandler.php"}}
<?php

namespace App\Kafka;

use App\Actions\Action;
use App\Actions\NotificationSendAction;
use App\Actions\UserIdentifyAction;
use Illuminate\Support\Facades\Log;


class ActionMapper
{
    public function mapPatternToAction(string $pattern): Action|null
    {
        switch ($pattern) {
            case 'notifications.send':
                return new NotificationSendAction;
            case 'users.identify':
                return new UserIdentifyAction;
            default:
                Log::error('No action mapped for pattern: ' . $pattern);
                return null;
        }
    }
}
  ```

In the above example, we have the `ActionMapper` class that is used to map the incoming message pattern to the appropriate action. The `KafkaCommandHandler` class is used to handle the incoming messages from the Kafka topics.

```php {{title: "app/Kafka/KafkaCommandHandler.php"}}
<?php

namespace App\Kafka;

use Junges\Kafka\Contracts\KafkaConsumerMessage;

class KafkaCommandHandler
{
    public static function handle(KafkaConsumerMessage $message): void
    {
        // You have to decode the message body to a PHP array because the message body is a JSON string from the Kafka topic.
        $body = json_decode($message->getBody(), true);

        $pattern = $body['pattern'];
        (new ActionMapper)
            ->mapPatternToAction($pattern)
            ?->handle($body['data']);
    }
}
```

In the above example, we have the `KafkaCommandHandler` class that is used to handle the incoming messages from the Kafka topics. It uses the `ActionMapper` class to map the incoming message pattern to the appropriate action.


